---
category: Basic
title: Stack Positioned
files:
  App.js: |
    import {
      StatefulWidget, 
      State,
      TextStyle,
      Container,
      Text,
      GestureDetector,
      EdgeInsets
    } from '@meursyphus/flitter';
    import Widget from '@meursyphus/flitter-react';

    class CustomWidget extends StatefulWidget {
      createState() {
        return new CustomState();
      }
    }


    class CustomState extends State {
      count = 1
      handleClick = () => {
        this.setState(() => {
          this.count++
        })
      }
      build(context) {
        return GestureDetector({
          onClick: this.handleClick,
          child: Container({
            color: 'blue',
            margin: EdgeInsets.all(20),
            padding: EdgeInsets.all(20),
            child: Text(`${this.count}`, {
              style: new TextStyle({
                color: 'white',
                fontSize: 20
              })
            })
          })
        })
      }
    }

    export default function App() {
      return (
        <Widget
          width="300px"
          height="300px"
          widget={new CustomWidget()}
        />
      )
    }
---

# Stateful Widget

In this tutorial, we will learn how to create a widget with state management using `StatefulWidget`. The `CustomWidget` class inherits from `StatefulWidget` and creates a `CustomState` state through the `createState` method. Within this state class, a `count` variable is managed, and a `handleClick` method is defined to increment this `count` value whenever a click event occurs.
The UI of the widget is handled by using a `GestureDetector` to process click events, and the actual UI is constructed using a `Container`. Inside the `Container`, a `Text` widget displays the current `count` value. All these processes are defined in the `build` method.
This example helps understand how to structure a stateful widget and how the UI updates in response to state changes.
Each call to `setState` changes the state, which triggers a re-rendering of the UI.
This allows the user interface to reflect the latest state.
